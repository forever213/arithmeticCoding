import numpy as np
import cv2
import math
import pickle


# I needed a function like this to help me trace the progress of the encoding and decoding
# so I search and get it from an answer on stackoverflow. It's just a utility function
def printProgressBar (iteration, total, prefix = '', suffix = '', decimals = 0, length = 100, fill = '█', printEnd = "\r"):
    percent = ("{0:." + str(decimals) + "f}").format(100 * (iteration / float(total)))
    filledLength = int(length * iteration // total)
    bar = fill * filledLength + '-' * (length - filledLength)
    print('\r%s |%s| %s%% %s' % (prefix, bar, percent, suffix), end = printEnd)
    # Print New Line on Complete
    if iteration == total: 
        print()


print('⏳Reading files generated by the encoder [imageInfo.npy], [tags.npy] and  [probabilities.pkl] ...')
# loading main files to start decoding
imageInfo = np.load('imageInfo.npy', None, True).tolist()
tags = np.load('tags.npy', None, True)

imgShape = imageInfo[0]
totalPixels = imgShape[0] * imgShape[1]
blockSize = imageInfo[1]
zerosAtEnd = imageInfo[2]

file = open("probabilities.pkl","rb")
probabilities = pickle.load(file)
file.close()

# a function that takes a symbol and the probability dictionary and returns the cumulative probability
def getSumProb(symbol, probDic):
    sum = 0
    probSymbol = 0

    for s in probDic:
        if(s == symbol):
            probSymbol = probDic[s]
            break
        else:
            sum += probDic[s]

    sumWithSymbol = sum + probSymbol

    return [sum, sumWithSymbol]


# a dictionary with the cumulative probabilty of each symbol
cumulativeProbDic = {}

for symbol in probabilities:
    cumulativeProbDic[symbol] = getSumProb(symbol, probabilities)


# decoding function that takes the tag, probability dictionary and cumulative Probability Dic and return the decoded
def decode(tag, prevLowerLimit, prevUpperLimit, probabilitiesDic, cumulativeProbDic, terminator,decoded=[]): 
    global counter # iterator to keep track of the number of function calls
    global decodedImg
    # terminate on this condition 
    if(counter == terminator):
        return
    
    # loop over all the symbols we have and get the range in which this tag exist
    for symbol in probabilitiesDic:
        currentUpperLimit = prevLowerLimit + ( prevUpperLimit - prevLowerLimit )*cumulativeProbDic[ symbol ][1]
        # if the tag exists in this range then this is the required symbol and we move on to get the next symbol
        if(tag <= currentUpperLimit ):
            decodedImg.append(symbol)
            counter+=1
            currentLowerLimit = prevLowerLimit + ( prevUpperLimit - prevLowerLimit )*cumulativeProbDic[ symbol ][0]
            return decode(tag, currentLowerLimit, currentUpperLimit, probabilitiesDic, cumulativeProbDic,terminator, decoded)            
          

decodedImg = []

counter=0
tagsLength = len(tags)
pixelsErrors = 0
for index,tag in enumerate(tags):
    printProgressBar(index+1, tagsLength, prefix = ' Progress:', suffix = 'Complete', length = 50)
    decode(tag, 0, 1, probabilities, cumulativeProbDic, blockSize, [])
    # print(counter)
    if(counter != blockSize):
        color = 0 
        decodedImgLength = len(decodedImg)

        for i in range (len(decodedImg)-16, len(decodedImg)):
            color += decodedImg[i]
        
        color = int(color/15)
        pixelsErrors += (blockSize-counter) + 4
        decodedImg = decodedImg[:decodedImgLength-4]
        for index in range(0, blockSize-counter+4):
            decodedImg.append(color)

    counter = 0

decodedImg=np.array(decodedImg[:len(decodedImg)-zerosAtEnd])
decodedImg = np.reshape(decodedImg, imgShape)
cv2.imwrite('output.jpg',decodedImg)
print('✅ Image saved as "output.jpg"')